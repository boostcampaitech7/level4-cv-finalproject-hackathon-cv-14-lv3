{
  "name": "category_finder",
  "nodes": [
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select distinct main from product_info",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        280,
        0
      ],
      "id": "a5b673b8-8deb-4d03-a957-04b19ff13430",
      "name": "Postgres",
      "credentials": {
        "postgres": {
          "id": "SCDcxHrlCbYx7hGl",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "f50d693b-452a-46db-911b-e222eb3120c9",
      "name": "When clicking ‘Test workflow’"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        220
      ],
      "id": "1f583ead-6e10-4a64-a7ce-586f9a366e86",
      "name": "When chat message received",
      "webhookId": "9c239947-cf36-4bc1-9f1a-db1ee8000ccf"
    },
    {
      "parameters": {
        "fileSelector": "~/Desktop/Hackerthon/category_embeddings.db",
        "options": {}
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        0,
        400
      ],
      "id": "6777e29b-512d-4860-8f68-0654c9f9063a",
      "name": "Read/Write Files from Disk",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import os\nimport sqlite3\nimport numpy as np\nfrom openai import OpenAI\nfrom typing import List, Dict, Tuple, ClassVar, Set\nfrom base64 import b64encode, b64decode\nimport tempfile\n\nclass CategorySearchNode:\n    \"\"\"카테고리 검색을 위한 클래스\n    \n    이 클래스는 임베딩된 카테고리 데이터베이스를 사용하여\n    주어진 텍스트에 가장 적합한 카테고리를 계층적으로 찾습니다.\n    \"\"\"\n    \n    # 유효한 카테고리 레벨 정의\n    VALID_LEVELS: ClassVar[Set[str]] = {\"main\", \"sub1\", \"sub2\", \"sub3\"}\n\n    def __init__(self, db_content: bytes, api_key: str | None = None):\n        \"\"\"CategorySearchNode 초기화\n        \n        Args:\n            db_content (bytes): 카테고리 데이터베이스 파일의 바이너리 내용\n            api_key (str | None): Upstage API 키. None인 경우 환경 변수에서 가져옴\n        \"\"\"\n        # API 키 설정\n        if not api_key:\n            api_key = os.getenv(\"UPSTAGE_API_KEY\")\n            if not api_key:\n                raise ValueError(\"Upstage API key is required\")\n        \n        # Upstage API 클라이언트 초기화\n        self.client = OpenAI(\n            api_key=api_key,\n            base_url=\"https://api.upstage.ai/v1/solar\"\n        )\n        \n        # 임시 데이터베이스 파일 생성\n        self.temp_db = tempfile.NamedTemporaryFile(suffix='.db', delete=False)\n        self.temp_db.write(db_content)\n        self.temp_db.close()\n        self.db_path = self.temp_db.name\n\n    def __del__(self):\n        \"\"\"소멸자: 임시 파일 정리\"\"\"\n        try:\n            os.unlink(self.db_path)\n        except:\n            pass\n\n    def deserialize_embedding(self, data: bytes) -> np.ndarray:\n        \"\"\"바이트 데이터를 넘파이 배열로 변환\n        \n        Args:\n            data (bytes): base64로 인코딩된 임베딩 데이터\n            \n        Returns:\n            np.ndarray: 디코딩된 임베딩 벡터\n        \"\"\"\n        return np.frombuffer(b64decode(data))\n\n    def get_embedding(self, text: str) -> np.ndarray:\n        \"\"\"텍스트의 임베딩 벡터 생성\n        \n        Args:\n            text (str): 임베딩할 텍스트\n            \n        Returns:\n            np.ndarray: 1024차원의 임베딩 벡터\n        \"\"\"\n        response = self.client.embeddings.create(\n            input=text,\n            model=\"embedding-query\"\n        )\n        return np.array(response.data[0].embedding)\n\n    def find_best_category(self, input_text: str) -> List[Dict[str, str]]:\n        \"\"\"입력 텍스트에 가장 적합한 카테고리 조합 찾기\n        \n        Args:\n            input_text (str): 검색할 텍스트\n            \n        Returns:\n            List[Dict[str, str]]: 계층별 최적 카테고리 목록\n                예: [{\"main\": \"Electronics\"}, {\"sub1\": \"Computers\"}, ...]\n        \"\"\"\n        # 입력 텍스트의 임베딩 생성\n        query_embedding = self.get_embedding(input_text)\n        results = []\n\n        try:\n            # 데이터베이스 연결\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n\n            # 1. Main 카테고리 검색\n            cursor.execute(\n                \"SELECT main, embedding FROM category_hierarchy WHERE sub1 = '' AND sub2 = '' AND sub3 = ''\"\n            )\n            main_categories = cursor.fetchall()\n            \n            best_main = None\n            best_main_similarity = -1\n\n            # 최적의 main 카테고리 찾기\n            for main, emb_blob in main_categories:\n                embedding = self.deserialize_embedding(emb_blob)\n                similarity = np.dot(query_embedding, embedding) / (\n                    np.linalg.norm(query_embedding) * np.linalg.norm(embedding)\n                )\n                if similarity > best_main_similarity:\n                    best_main_similarity = similarity\n                    best_main = main\n\n            if best_main:\n                results.append({\"main\": best_main})\n\n                # 2. Sub1 카테고리 검색\n                cursor.execute(\n                    \"\"\"SELECT sub1, embedding \n                    FROM category_hierarchy \n                    WHERE main = ? AND sub1 != '' AND sub2 = '' AND sub3 = ''\"\"\",\n                    (best_main,)\n                )\n                sub1_categories = cursor.fetchall()\n                \n                best_sub1 = None\n                best_sub1_similarity = -1\n\n                # 최적의 sub1 카테고리 찾기\n                for sub1, emb_blob in sub1_categories:\n                    embedding = self.deserialize_embedding(emb_blob)\n                    similarity = np.dot(query_embedding, embedding) / (\n                        np.linalg.norm(query_embedding) * np.linalg.norm(embedding)\n                    )\n                    if similarity > best_sub1_similarity:\n                        best_sub1_similarity = similarity\n                        best_sub1 = sub1\n\n                if best_sub1:\n                    results.append({\"sub1\": best_sub1})\n\n                    # 3. Sub2 카테고리 검색\n                    cursor.execute(\n                        \"\"\"SELECT sub2, embedding \n                        FROM category_hierarchy \n                        WHERE main = ? AND sub1 = ? AND sub2 != '' AND sub3 = ''\"\"\",\n                        (best_main, best_sub1)\n                    )\n                    sub2_categories = cursor.fetchall()\n                    \n                    best_sub2 = None\n                    best_sub2_similarity = -1\n\n                    # 최적의 sub2 카테고리 찾기\n                    for sub2, emb_blob in sub2_categories:\n                        embedding = self.deserialize_embedding(emb_blob)\n                        similarity = np.dot(query_embedding, embedding) / (\n                            np.linalg.norm(query_embedding) * np.linalg.norm(embedding)\n                        )\n                        if similarity > best_sub2_similarity:\n                            best_sub2_similarity = similarity\n                            best_sub2 = sub2\n\n                    if best_sub2:\n                        results.append({\"sub2\": best_sub2})\n\n                        # 4. Sub3 카테고리 검색\n                        cursor.execute(\n                            \"\"\"SELECT sub3, embedding \n                            FROM category_hierarchy \n                            WHERE main = ? AND sub1 = ? AND sub2 = ? AND sub3 != ''\"\"\",\n                            (best_main, best_sub1, best_sub2)\n                        )\n                        sub3_categories = cursor.fetchall()\n                        \n                        best_sub3 = None\n                        best_sub3_similarity = -1\n\n                        # 최적의 sub3 카테고리 찾기\n                        for sub3, emb_blob in sub3_categories:\n                            embedding = self.deserialize_embedding(emb_blob)\n                            similarity = np.dot(query_embedding, embedding) / (\n                                np.linalg.norm(query_embedding) * np.linalg.norm(embedding)\n                            )\n                            if similarity > best_sub3_similarity:\n                                best_sub3_similarity = similarity\n                                best_sub3 = sub3\n\n                        if best_sub3:\n                            results.append({\"sub3\": best_sub3})\n\n        finally:\n            conn.close()\n\n        return results\n\ndef process_node(input_items: List[Dict]) -> List[Dict]:\n    \"\"\"n8n 노드의 입력 처리\n    \n    Args:\n        input_items (List[Dict]): n8n의 입력 아이템 목록\n        \n    Returns:\n        List[Dict]: 처리된 아이템 목록\n        \n    각 입력 아이템은 다음 형식을 가져야 합니다:\n    {\n        \"binary\": {\n            \"db_file\": {\n                \"data\": bytes,  # 데이터베이스 파일 내용\n                \"mimeType\": \"application/x-sqlite3\"\n            }\n        },\n        \"json\": {\n            \"input_text\": str  # 검색할 텍스트\n        }\n    }\n    \"\"\"\n    # API 키 가져오기\n    api_key = os.getenv(\"UPSTAGE_API_KEY\")\n    if not api_key:\n        raise ValueError(\"UPSTAGE_API_KEY not found in environment variables\")\n\n    # 각 입력 아이템 처리\n    for item in input_items:\n        # 필수 입력 확인\n        if 'db_file' not in item.binary:\n            raise ValueError(\"Missing database file in binary input\")\n        if 'input_text' not in item.json:\n            raise ValueError(\"Missing input_text in JSON input\")\n\n        # 카테고리 검색 수행\n        searcher = CategorySearchNode(item.binary['db_file'].data, api_key=api_key)\n        results = searcher.find_best_category(item.json['input_text'])\n        \n        # 결과 저장\n        item.json['categories'] = results\n    \n    return input_items\n\n# n8n에서 실행될 코드\nif __name__ == \"__main__\":\n    return process_node(_input.all())"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        280,
        220
      ],
      "id": "9748a5a7-9b6a-45f9-a5e6-791f32803682",
      "name": "CategoryFinder"
    },
    {
      "parameters": {
        "content": "### Input format:\n{\n    \"binary\": {\n        \"db_file\": {\"data\": \"...\"}\n    },\n    \"json\": {\n        \"input_text\": \"gaming laptop\"\n    }\n}\n\n### Output format:\n{\n    \"binary\": {\n        \"db_file\": {\"data\": \"...\"}\n    },\n    \"json\": {\n        \"input_text\": \"gaming laptop\",\n        \"categories\": [\n            {\"main\": \"Electronics\"},\n            {\"sub1\": \"Computers\"},\n            {\"sub2\": \"Laptops\"},\n            {\"sub3\": \"Gaming Laptops\"}\n        ]\n    }\n}",
        "height": 520,
        "width": 320
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        500,
        220
      ],
      "typeVersion": 1,
      "id": "2e78de04-4759-4aad-84bb-91699bf33256",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "### Goal\n임의의 값을 입력받았을 때, Embedded categories를 통해서 가장 적합한 categories(main, sub1, sub2, sub3)을 추론하는 것\n\n### Required \n- category_embeddings.db가 필요합니다.\n- python package가 설치된 Dockerfile을 활용해서 n8n을 실행해야 합니다. 아래의 링크를 참고해주세요.\n- github.com/Namgyu-Youn/n8n-solar/blob/master/docker/images/n8n-custom/Dockerfile",
        "height": 520,
        "width": 320
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        840,
        220
      ],
      "typeVersion": 1,
      "id": "118faeaf-7a94-43ef-a3fd-e31aa4ab882d",
      "name": "Sticky Note1"
    }
  ],
  "pinData": {},
  "connections": {
    "Postgres": {
      "main": [
        []
      ]
    },
    "When clicking ‘Test workflow’": {
      "main": [
        [
          {
            "node": "Postgres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "CategoryFinder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read/Write Files from Disk": {
      "main": [
        [
          {
            "node": "CategoryFinder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7b9c451b-3136-49b7-b8fc-f794fc2bbd47",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "d4adb49d182020a0902b2114e978ac8272f9ff5e02883761bccd2a608155440a"
  },
  "id": "8Gmyg7XceaVg9CJ8",
  "tags": []
}